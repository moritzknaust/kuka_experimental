&ACCESS RVP
&REL 17
DEF  kuka_eki_hw_interface()

   ; Software License Agreement (BSD License)
   ;
   ; Copyright (c) 2020, TU Darmstadt
   ; All rights reserved.
   ;
   ; Redistribution and use in source and binary forms, with or without
   ; modification, are permitted provided that the following conditions are met:
   ;
   ;      * Redistributions of source code must retain the above copyright
   ;        notice, this list of conditions and the following disclaimer.
   ;      * Redistributions in binary form must reproduce the above copyright
   ;        notice, this list of conditions and the following disclaimer in the
   ;        documentation and/or other materials provided with the distribution.
   ;      * Neither the name of the copyright holder, nor the names of its
   ;        contributors may be used to endorse or promote products derived
   ;        from this software without specific prior written permission.
   ;
   ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   ; POSSIBILITY OF SUCH DAMAGE.

   ; Author: Moritz Knaust (TU Darmstadt) <moritz.knaustrmr.tu-darmstadt.de>


   ; Declarations
   DECL AXIS joint_pos_tgt
   DECL INT elements_read

   ; INI
   BAS(#INITMOV, 0)  ; Basic initializasion of axes

   ; Initialize eki_hw_interface server
   ;   Config located in C:/ROBOTER/Config/User/Common/EthernetKRL/EkiHwInterface.xml
   ;   Starts a TCP state sever on xml-specified IP address/port.
   ;
   ;   State transmission is periodic (currently determined by $TIMER[1]=-## line in
   ;   eki_hw_iface_send()
   ;
   ;   Joint position commands execute as they come in.
   ;   PTP motions are blended in joint-space via C_PTP approximation when possible
   ;   via the advance run.  The advance run will read and blend command points as
   ;   soon as the become available up to value set in $advance (in range [0, 5])
   ;
   ;   Utilized system resources:
   ;     Flags:
   ;       $FLAG[1]:        Indicates active client connection
   ;       $timer_flag[1]:  Used to trigger periodic send of robot state
   ;     Interrupts:
   ;       15: Calls eki_hw_iface_reset() on falling edge of $FLAG[1]
   ;       16: Calls eki_hw_iface_send() on rising edge of $timer_flag[1]
   eki_hw_iface_init()

   ; BCO (Block COincidence) run to current position
   ; (requied for below loop continue before first incoming command)
   joint_pos_tgt = $AXIS_ACT
   PTP joint_pos_tgt

   ; Loop forever
   $ADVANCE = 5
   loop
      elements_read = eki_hw_iface_get(joint_pos_tgt)  ; Get new command from buffer if present
      IF elements_read == 1 THEN
         PTP joint_pos_tgt C_PTP                          ; PTP to most recent commanded position  
   ENDIF

   endloop



   ; Note: EKI channels delete on reset or deselect of this program
   ;       See <ENVIRONMENT>Program</ENVIRONMENT> EKI config element
END



DEF eki_hw_iface_init()
   DECL INT eki_ret

   ; Setup interrupts
   ; Interrupt 15 - Connection cleanup on client disconnect
   GLOBAL INTERRUPT DECL 15 WHEN $FLAG[1]==FALSE DO eki_hw_iface_reset()
   INTERRUPT ON 15
   ; Interrupt 16 - Timer INTERRUPT for periodic state transmission
   GLOBAL INTERRUPT DECL 16 WHEN $timer_flag[1]==TRUE DO eki_hw_iface_send()
   INTERRUPT ON 16
   WAIT SEC 0.012          ; Wait for next interpolation cycle
   $TIMER[1] = -200        ; Time in [ms] before first INTERRUPT call
   $TIMER_STOP[1] = FALSE  ; Start timer 1

   ; Create and open EKI interface
   eki_ret = EKX_OPEN("EkiHwInterface")
EKX_HandleError(eki_ret)
$FLAG[1]=TRUE
END



DEF eki_hw_iface_send()
   DECL INT eki_ret
   DECL real vel_percent

   IF $FLAG[1] THEN  ; If connection alive
      ; Load state values into xml structure
      ; position
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A1", $AXIS_ACT.a1)
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A2", $AXIS_ACT.a2)
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A3", $AXIS_ACT.a3)
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A4", $AXIS_ACT.a4)
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A5", $AXIS_ACT.a5)
      eki_ret = EKX_WriteReal("EkiHwInterface.RobotState.Pos.A6", $AXIS_ACT.a6)
      ; velocity
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A1", $vel_axis_act[1] * $vel_axis_ma[1] / 100.0)
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A2", $vel_axis_act[2] * $vel_axis_ma[2] / 100.0)
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A3", $vel_axis_act[3] * $vel_axis_ma[3] / 100.0)
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A4", $vel_axis_act[4] * $vel_axis_ma[4] / 100.0)
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A5", $vel_axis_act[5] * $vel_axis_ma[5] / 100.0)
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Vel/A6", $vel_axis_act[6] * $vel_axis_ma[6] / 100.0)
      ; effort
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A1", $torque_axis_act[1])
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A2", $torque_axis_act[2])
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A3", $torque_axis_act[3])
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A4", $torque_axis_act[4])
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A5", $torque_axis_act[5])
      ;eki_ret = EKX_WriteReal("EkiHwInterface.RobotState/Eff/A6", $torque_axis_act[6])
      ; interface state
      ; eki_ret = eki_checkbuffer("EkiHwInterface.RobotCommand/Pos/A1")
      eki_ret = EKX_WriteInteger("EkiHwInterface.RobotState.RobotCommand.Size", 1) ; TODO test this!

      ; Send xml structure
      IF $FLAG[1] then  ; Make sure connection hasn't died while updating xml structure
         eki_ret = EKX_SEND("EkiHwInterface")
         EKX_HandleError(eki_ret)
      ENDIF
   ENDIF

   ; Set timer for next INTERRUPT [ms]
   $TIMER[1] = -10  ; ~10 ms for above send + 10 ms INTERRUPT timer -> ~50 Hz state transmission
END

; eki_hw_iface_get
; Tries to read most recent elemnt from buffer. q left unchanged if empty.
; Returns number of elements read.
DEFFCT INT eki_hw_iface_get(joint_pos_cmd :out)
   DECL BOOL eki_ret
   DECL BOOL bNew
   DECL AXIS joint_pos_cmd
   DECL INT read_order
   read_order = 0    ; 0=FIFO, 1=LIFO

   IF not $FLAG[1] then
      return 0
   ENDIF

   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A1", joint_pos_cmd.a1, bNew)
   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A2", joint_pos_cmd.a2, bNew)
   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A3", joint_pos_cmd.a3, bNew)
   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A4", joint_pos_cmd.a4, bNew)
   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A5", joint_pos_cmd.a5, bNew)
   eki_ret = EKX_GetRealElement(read_order, "EkiHwInterface.RobotCommand.Pos.A6", joint_pos_cmd.a6, bNew)
   IF eki_ret == FALSE THEN 
      return 0
   ENDIF
   IF bNew == FALSE THEN
      return 0
   ENDIF
return 1
ENDFCT



DEF eki_hw_iface_reset()
   DECL INT eki_ret
   DECL BOOL eki_err

   eki_err = EKX_Close("EkiHwInterface")
   
   eki_ret = EKX_Open("EkiHwInterface")
   EKX_HandleError(eki_ret)
   $FLAG[1]=TRUE
   
END